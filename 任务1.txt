深度思考

1.maven是什么，和Ant有什么区别？

        maven是项目构建工具，与Ant的区别是

        ①maven具有固定的项目结构，提高了项目的可移植性

        ② Maven是申明式的，用pom.xml文件；而Ant是程序式的，构建过程需要自定义，用builder.xml.

        ③ Maven是有生命周期的，而Ant没有。

        ④ Maven内置依赖管理和Repository来实现依赖的管理和统一存储；而Ant没有。Maven第一次install的时候会把依赖的jar包和构件从远处库下载到本地库（先从本地仓库找）。Maven还可以管理传递依赖。

       ⑤Maven配置比较简单，有很多的约定、规范、标准，可以用较少的代码干更多的事；而Ant配置比较麻烦，需要配置整个构建的过程（但Ant配置灵活）。

2.clean,install,package,deploy分别代表什么含义？

        clean：清除生成文件  install 将打包文件输送到本地仓库  package 打包文件    deploy部署已打包文件到远程仓库

3.怎么样能让Maven跳过JUnit?

        第一种：在pom.xml文件中加入

<plugin>
       <groupId>org.apache.maven.plugins</groupId>
       <artifactId>maven-surefire-plugin</artifactId>
       <configuration>
         <skip>true</skip>
       </configuration>
 </plugin

     第二种：使用idea时点击maven窗口的闪电标志

     第三种：使用命令行时


mvn compile install -DskipTests

mvn compile install -Dmaven.test.skip=true

4.为什么要用Log4j来替代System.out.println？

        System.out.println只能简单的输送信息，而Log4j可以选择级别，输送日期、级别、线程等等，还可以输出到文件中，功能比简单的println强大很多

5.为什么DB的设计中要使用Long来替换掉Date类型？

        除去要考虑到时区的情况，使用Long类型可以方便的计算两个日期之间的时间差，而且可以优化数据库检索效率

6.自增ID有什么坏处？什么样的场景下不使用自增ID？

        自增ID在合并数据库、旧数据导入、时需重新编辑数据，否则会互相覆盖；当数据类型中有不重复、检索频率高的情况下， 不使用自增ID；在分布式系统下不使用自增ID

7.什么是DB的索引，多大的数据量下建索引会有性能的差别，什么样的情况下该对字段建索引？

       索引是数据库的一种结构，相当于图书馆的目录；

       看了百度好几页，发现说法不一，大概是10w条数据以上要建索引，但还是得分析具体情况；

       在where、order by、group by的字段建立索引，也就是说要在查询、排序、分组的字段建立索引

8.唯一索引和普通索引的区别是什么，什么时候需要建唯一索引。

       建立唯一索引的字段，不能插入重复的值，也因为这种特性，唯一索引更具效率；

       在已有主键的情况下，若有其他不允许重复的数据字段，则应该使用唯一索引

9.如果对学员QQ号做了一个唯一索引，在插入数据的时候，是否需要先判断这个QQ号已经存在了？

        不需要，若有重复数据，数据库会直接拒绝此次数据的插入

10.CreateAt和UpdateAt的意义分别是创建时间和修改时间，这两个时间应该在什么情况下赋值？是否应该开放给外部调用的接口？

       CreateAT在创建的时候赋值，UpdateAt在此后每次更新此条数据的时候赋值；

       可以使用数据库的触发器直接赋值，不需要开放给外部调用接口

11.修真类型应该是直接存储Varchar，还是应该存储int?

        修真类型数量有限，可以用int数据直接代替，已节约数据库的空间，调用时再使用接口还原

12.varchar类型的长度怎么确定？有什么样的原则，和Text和LongText的区别是什么？

        采用按需定义原则，例如QQ号最大长度为11，则长度是“11+1”；

        text：可变长度，最多65535个字符；可变长度，最多2的32次方-1个字符

13.怎么进行分页数据的查询，如何判断是否有下一页？

       select * from userdetail where userid limit (pageNow-1)*pageSize,pageSize;

      例如要每页一百条数据，要查第五页数据，SQL语句就是

      select * from userdetail where userid limit (5-1)*100,100;

      怎么判断没有搜到，看了杨瞬师兄的日报

     假如每页显示 20 条数据，那么查询数据库的时候，用limit #offset#, 21取出 21 条记录，页面展现20条。如果取到了 21 条，说明下一页还有数据。如果结果集数量不足 21，说明已经到了最后一页。

      

14.为什么不可以用Select * from table?

        数据量大的时候查询的效率会严重下降，要查询什么要列出来，提高系统的效率

15.什么是贫血模型，什么是充血模型？为什么我们会强制要求使用贫血模型？

       贫血模型是指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。

       充血模型层次结构和上面的差不多，不过大多业务逻辑和持久化放在Domain Object里面，Business Logic只是简单封装部分业务逻辑以及控制事务、权限等，这样层次结构就变成Client->（Business Facade）->Business Logic->Domain Object->Data Access Object。

16.Spring中的IOC是什么意思，为什么要用IOC而不是New来创建实例？

        控制反转；使用控制反转实现了对象之间的解绑，当我们需要重构代码的时候不需要整个更改代码，只需要更改我们想要更改的子类和xml文件就可以了

17.为什么要使用Interface，而不是直接使用一个实体类来完成任务？Interface和Impl这种方式的好处是什么？

        增强了代码的可维护性和扩展性，当他人阅读实现类时，可以直接观看interface要做什么，而不用关心它是怎么样实现的

18.为什么要处理异常，Try/Catch应该在什么样的场景下使用，在真实的系统中，会出现网络中断，DB连接不上的错误吗？多久会发 生一次？

        大多数错误处理机制依靠的是程序员自身的警惕性，而不是编程语言强制的，因如果程序员不够警惕，出错的几率很大。java中把异常处理机制放到编程语言中，因此强制程序员去使用他，不然无法编译通过。更重要的是异常不能被忽略，保证一定要去处理它。异常提供了从错误状态进行可靠恢复的途径，而不需要退出程序。在可能会抛出异常的地方使用Try/Catch

19.日志应该怎么打，在什么位置，需要打印出来什么样的关键参数？

       位置：1. 对外部的调用封装   2.状态变化  3.系统入口与出口   4.业务异常  5.非预期执行  6.很少出现的else情况

       参数：1. 程序运行时间  2. 大批量数据的执行进度  3.关键变量及正在做哪些重要的事情

20.为什么需要单步调试？Debug的时候IDE是怎么找到源码的？

        根据单步调试的变量，找到程序出错的地方

21.可否远程连接到线上直接调试？真实的项目中，遇到问题的排查方案是什么？

        可以使用tomcat的远程调试功能；排查方案没找到，看的师兄的


处理还排除故障分为4个必须的步骤：

（1）紧急处理

（2）添加监控

 （3）使用JDK性能监控工具

 （4）分析源代码。从治标不治本，到治标又治本

紧急处理

     紧急处理，顾名思义，是检查和评度当前故障的影响范围，并尽快使服务先恢复起来。其中检查和评估当前故障的影响范围是非常重要的。以微博系统举例，一般用户的投诉率为千分之一，如果有超过10起用户投诉，就可能是大面积故障。如果只是负责线上跟踪的QA人员反馈的问题，而没有用户投诉，则可以有较多的时间去处理。

      对于紧急的大面积故障，首先想到的不应该是检查问题。而是需要立刻追查最近线上系统是否有更改，我们经验是95%的故障都是在新代码上线后的12小时内发生的。此时应立刻回滚新更改。另外5%的大部分是由于业务扩展导致的。互联网业有一个规律，线上系统每半年需要重构一次，否则无法对应业务量的增长。对于这种业务量增长造成的故障，通常可以通过重启服务来紧急处理。

       因此，紧急处理的首选是立刻回滚新更改。

添加监控

       紧急处理之后，服务已经恢复了，但是问题并没有找到。如果是新代码上线造成的故障，回滚之后，工程师会有各种手段，在测试环境追查问题。而针对系统容量不足造成的故障，需要特别添加监控作为追查问题的重要手段。因为互联网业务请求高峰和低谷差别非常明显，微博业务中的请求高峰往往出现在晚上10点左右，而且不是稳定的出现。要求工程师们每天悲催的坐在电脑前守到晚上10点，却不见得能发现问题，是非常低效的。监控一般用一个简单的脚本就可以搞定，比如http服务监控。



使用JDk性能监控工具

      刚刚添加的监控开始报警了。登上服务器，该做些什么呢？一般需要如下动作

      （1）首先查看日志，看看有没有Exception。另外日志中常常有对接口调用，缓存使用的监控告警信息。

       （2）看看目前gc的状况如何，使用jdk自带的工具就可以

        （3）jmap -histo vmid > jmap.log，该命令会打出所有对象，包括占用的byte数和实例个数。

   （4）检查目前cpu占用情况，top -H，然后按“1”，会看到当前进程中每个线程所占CPU的比例。注意观察前几名，然后jstack -l vmid > jstack.log打出线程堆栈，看看是什么线程占用了CPU。这里需要注意的是，top -H显示的线程id是十进制，而jstack打出的线程堆栈是16进制。看看那些最忙的thread是不是那些真正应该忙的thread，如果是一些“黑马”线程，则要考虑是否是代码有死循环或者是意外的问题。



分析源代码

          分析源代码是最有技术含量的事情，也是比较耗时而且不见得有效果的事情。所以我把源码分析放到解决线上问题的最后一步，因为必须要做到“有的放矢”。带着问题去分析代码，会比较容易。通过20%代码的修改，就可以解决80%的性能问题。比如上面这个线上问题，肯定是线程处理慢造成的问题。需要针对线程的调用，同步异步等进行分析。

以上是csdn博客上分享的一篇java线上服务故障的方法和实例分析，自己看得半懂不懂。之前有过几年游戏项目开发经验（我是策划），一般我们遇到故障的处理方式如下。

1.确定故障出现场景，在测试环境还原它

2.svn上根据上传记录回滚，确定导致故障出现的是谁什么时候上传的什么文件

3.找到上传出现问题的文件之后，找到对应的人员从修改部分着手解决问题（考验程序架构的时候到了）

4.内部版本修改，内部测试通过

5.发布补丁，公告补偿，停服重启（技术还没实现热更新）